(*

Copyright Jeremy Siek and Manish Vachharajani, November 11, 2007

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*)

open Support.Pervasive
open Support.Error
open Printf
open Graph_ast
open Parser_misc


let rec generate_constraints env e =
  match e with
      VarE (i, x) ->
	(try
	    ([], List.assoc x env)
	  with Not_found ->
	    error i (sprintf "Undefined variable %s" x))
    | IntE (i, n) ->
	([], create_int i)
    | BoolE (i, n) ->
	([], create_bool i)
    | LamE (i, x, t, e) ->
	let (cns,t_e) = generate_constraints ((x,t)::env) e in
	  (cns, create_arrow i t t_e)
    | AppE (i, rator, rand) ->
	let (cns1, t_rator) = generate_constraints env rator in
	let (cns2, t_rand) = generate_constraints env rand in
	let b = uniquify_name "beta" in
	let beta = create_var i b in
	let ar = create_arrow i t_rand beta in
	  (cns1 @ cns2 @ [(t_rator, ar)], beta)

let rec copy_dyn v =
  let v = find v in
  let i = (g#get v).inf in
  match (g#get v).stype with
      VarT (_, alpha) -> v
    | ArrowT (_, s,t) -> 
	let ns = copy_dyn s and nt = copy_dyn t in
	  create_arrow i ns nt
    | IntT _ -> v
    | BoolT _ -> v
    | DynT _ -> create_dyn i

let rec copy_dyn_cns cns =
  match cns with
      [] -> []
    | (t1,t2)::cns ->
	(copy_dyn t1, copy_dyn t2)::(copy_dyn_cns cns)


let order u v =
  match ((g#get u).stype, (g#get v).stype) with
      (DynT _, VarT _) ->
	(u, v, true)
    | (DynT _,_) | (VarT _, _) ->
	(v, u, true)
    | (_, VarT _) | (_, DynT _) -> (* added this clause to fix a bug -Jeremy *)
	(u, v, true)
    | _ -> (u, v, false)

let rec solve_iter cns =
  match cns with
      [] -> ()
    | (x,y)::cns ->
	let u = find x and v = find y in
	  if u = v then
	    solve_iter cns
	  else
	    let (u,v,flag) = order u v in
	    let s = (g#get u).stype and t = (g#get v).stype in
	    let _ = union u v flag in
	      (match (s, t) with
		  (ArrowT (_,u1,u2), ArrowT (_,v1,v2)) ->
		      solve_iter ((u1,v1)::(u2,v2)::cns)
		| (ArrowT (_,u1,u2), DynT _) ->
		      if (g#get u).contain_vars then (
			  (g#get u).contain_vars <- false;
			  let w1 = create_dyn (g#get u).inf
			  and w2 = create_dyn (g#get u).inf in
			    solve_iter ((u1,w1)::(u2,w2)::cns))
		      else
			solve_iter cns
		| (_, VarT _) | (_, DynT _) | (IntT _,IntT _) | (BoolT _,BoolT _) ->
		    solve_iter cns
		| _ -> error (g#get u).inf (sprintf "%s and %s are not consistent"
					 (print_type u s) (print_type v t)))
			     

let create_quotient_graph g =
  let g' = new Graph.adjacency_list 0 () () in
  let vs = List.map
    (fun v -> let v' = g'#add_vertex () in (v,v'))
    (List.filter (fun v -> find v = v) g#vertices) 
  in
    List.iter
      (fun e ->
	let u = e#source and v = e#target in
	  if find u = u then
	    let _ = g'#add_edge (List.assoc u vs) (List.assoc (find v) vs) () in ()
      )
      g#edges;
    g'


let solve cns =
  let cns = copy_dyn_cns cns in
    solve_iter cns;
    let g' = create_quotient_graph g in
      try
	Graph.detect_cycles g' (fun e -> true);
      with Graph.Has_cycle ->
	printf "there is a cycle, no solution\n";
	raise (Exit 1)




(*  

    For reference, the following is Huet's algorithm (without gradual
    typing).

*)

let vanilla_order u v =
  match ((g#get u).stype, (g#get v).stype) with
    | (VarT _, _) -> (v, u)
    | _ -> (u,v)

let rec vanilla_solve_iter cns =
  match cns with
      [] -> ()
    | (x,y)::cns ->
	let u = find x and v = find y in
	  if u = v then
	    vanilla_solve_iter cns
	  else
	    let (u,v,flag) = order u v in
	    let s = (g#get u).stype and t = (g#get v).stype in
	    let _ = union u v flag in
	      (match (s, t) with
		  (ArrowT (_,u1,u2), ArrowT (_,v1,v2)) ->
		    vanilla_solve_iter ((u1,v1)::(u2,v2)::cns)
		| (_, VarT _) | (IntT _,IntT _) | (BoolT _,BoolT _) ->
		    vanilla_solve_iter cns
		| _ -> error (g#get u).inf (sprintf "%s and %s should be equal"
					       (print_type u s) (print_type v t)))

let vanilla_solve cns =
  let cns = copy_dyn_cns cns in
    vanilla_solve_iter cns;
    let g' = create_quotient_graph g in
      try
	Graph.detect_cycles g' (fun e -> true);
      with Graph.Has_cycle ->
	error UNKNOWN "there is a cycle, no solution"

let vanilla_infer e =
  let (cns,t) = generate_constraints [] e in
    vanilla_solve cns;
    t

(*
  The top-level inference algorithm.
*)


let infer e =
  let (cns,t) = generate_constraints [] e in
    (match !strategy with
	GradualInference ->
	  solve cns
      | SimpleInference ->
	  vanilla_solve cns);
    t

